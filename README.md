# Build-My-Own-Redis
A Redis-like in-memory key-value store built in Java.
This project is part of my journey to master core Java concepts such as socket programming, multithreading, and protocol parsing. It simulates basic Redis functionality and helps me understand how network servers manage client connections and interpret communication protocols.
Build Your Own Redis - Comprehensive Documentation GuideThis document provides a detailed guide to the "Build Your Own Redis" project, an in-memory key-value store implemented in Java. The project serves as a learning exercise to understand core Java concepts, socket programming, and basic network server functionalities.Table of ContentsIntroductionCore ConceptsIn-Memory Key-Value StoreSocket Programming (TCP/IP)Multi-threading for Client HandlingSimplified RESP (Redis Serialization Protocol)Project StructureFeatures and ImplementationServer Setup (Main.java)Client Handler (ClientHandler.java)Data Store (SetGetHandler.java and associated data structures)Replication Client (ReplicaClient.java)Stream Handling (StreamHandler.java)Command ParsingSupported CommandsPINGECHOSETGETDELCONFIG GETKEYS *INFO replicationREPLCONFPSYNCWAITXADDTYPEError HandlingFuture EnhancementsContributingLicense1. Introduction"Build Your Own Redis" is a Java-based project that emulates a simplified version of the popular Redis in-memory data structure store. It provides a foundation for understanding how network servers operate, manage multiple client connections, and handle basic protocol parsing. The server listens for incoming connections, processes commands sent by clients, and stores data in a volatile in-memory key-value map. It also includes initial support for replication and streams.3. Core ConceptsUnderstanding these fundamental concepts is crucial for grasping how the Redis-like server operates.In-Memory Key-Value StoreThe server stores all data in RAM using a ConcurrentHashMap. This provides fast access times but means data is volatile and will be lost when the server restarts.Socket Programming (TCP/IP)The server uses Java's java.net.ServerSocket and java.net.Socket classes to establish TCP/IP connections.A ServerSocket listens for incoming client connections on a specific port.When a client connects, the ServerSocket accepts the connection, creating a Socket object for communication with that specific client.Socket objects provide input and output streams for sending and receiving data over the network.Multi-threading for Client HandlingTo handle multiple concurrent client connections, the server employs multi-threading. Each time a new client connects, a new Thread is created, and an instance of ClientHandler is run within that thread. This ensures that one slow client does not block other clients from being processed.Simplified RESP (Redis Serialization Protocol)Redis communicates using the Redis Serialization Protocol (RESP). This project implements a simplified version of RESP for arrays and bulk strings.Arrays: Start with * followed by the number of elements, terminated by \r\n.Bulk Strings: Start with $ followed by the length of the string, terminated by \r\n, followed by the actual string, terminated by \r\n.Example of SET mykey myvalue in simplified RESP:*3\r\n           (Array of 3 elements)
$3\r\n           (Bulk string of length 3)
SET\r\n          (The command "SET")
$5\r\n           (Bulk string of length 5)
mykey\r\n        (The key "mykey")
$7\r\n           (Bulk string of length 7)
myvalue\r\n      (The value "myvalue")

The server parses these incoming bytes to extract the command and its arguments.4. Project StructureThe project has a straightforward structure.Build-My-Own-Redis/
├── src/
│   └── main/
│       └── java/
│           └── Main/
│               ├── ClientHandler.java   // Handles individual client connections
│               ├── RDBConfig.java       // Handles RDB file configuration and parsing
│               ├── ReplicaClient.java   // Handles replica-side logic and connection to master
│               ├── Main.java            // Main server application entry point
│               ├── SetGetHandler.java   // Handles SET and GET commands, and key expiry
│               ├── StreamHandler.java   // Handles stream commands like XADD
│               └── RDBKeyHandler.java   // (Assumed) Handles loading keys from RDB file
├── pom.xml (optional, if using Maven)
└── README.md

Main.java: The primary entry point of the application, responsible for command-line argument parsing, server setup, accepting new client connections, and managing global shared data structures and replication status.ClientHandler.java: A runnable class that processes commands for a single client connection in its own thread.SetGetHandler.java: A static helper class responsible for handling SET and GET commands, including optional arguments like EX, PX, NX, and XX, as well as managing key expiration and propagating SET commands to replicas.StreamHandler.java: A static helper class responsible for handling stream commands like XADD and managing stream IDs.RDBConfig.java: A class to manage configuration parameters related to RDB persistence (e.g., directory, filename) parsed from command-line arguments.ReplicaClient.java: A static class that manages the client-side logic when the server instance is configured as a replica, including connecting to the master and handling replication protocols.RDBKeyHandler.java: (Assumed) A class responsible for loading key-value pairs from a Redis RDB file into the in-memory store.5. Features and ImplementationThis section details the functionality and implementation of each core component and supported command.Server Setup (Main.java)Main.java is the primary class that initializes the Redis-like server. It handles command-line argument parsing, sets up the server socket, and manages the lifecycle of client connections.Functionality:Parses Command-Line Arguments: Detects --port to set the server's listening port and --replicaof to configure the server as a replica, specifying the master's host and port.Initializes Shared Data Structures: Declares and initializes thread-safe ConcurrentHashMap for storing key-value pairs (store), expiration timestamps (expiry), stream data (streams), and last stream IDs (lastStreamIds).Manages Replication State: Maintains isMaster status, master_replID, master_repl_offset, and a list of connectedReplicasWriters for master-replica communication.Loads RDB File: Before starting the server, it delegates RDB configuration parsing to RDBConfig and then loads existing data from the RDB file into the store via RDBKeyHandler.Starts Expiry Cleanup: Initiates a background thread for proactive key expiration management using SetGetHandler.startExpiryCleanup.Connects to Master (if replica): If configured as a replica, it calls ReplicaClient.connectToMaster to establish and maintain the connection with its master server.Accepts Client Connections: Creates a ServerSocket on the configured port and continuously accepts new client connections, spawning a new ClientHandler thread for each.Class Fields:private static final ConcurrentHashMap<String, String> store: The main in-memory store for string key-value pairs.private static final ConcurrentHashMap<String, Long> expiry: Stores expiration timestamps for keys.private static final ConcurrentHashMap<String, TreeMap<String, ConcurrentHashMap<String, String>>> streams: Stores Redis Stream data.private static final ConcurrentHashMap<String, String> lastStreamIds: Tracks the last generated ID for each stream.private static boolean isMaster = true: Flag indicating if this server is a master (default) or a replica.private static final CopyOnWriteArrayList<BufferedWriter> connectedReplicasWriters: List of writers to connected replica clients (managed by master).private static String master_replID = "8371b4fb1155b71f4a04d3e1bc3e18c4a990aeeb": Hardcoded replication ID for the master.private static int master_repl_offset = 0: Replication offset for the master.public static boolean isReplicaReady = false: Flag indicating when a replica is ready to receive commands from its master after handshake.private static int countofReplica = 0: Tracks the number of connected replicas.getreplicacount() Method:public static int getreplicacount(): Returns the current count of connected replicas (countofReplica).getMasterReplID() Method:public static String getMasterReplID(): Returns the master's replication ID.getMasterReplOffset() Method:public static int getMasterReplOffset(): Returns the master's replication offset.main(String[] args) Method - Detailed Algorithm:RDB Configuration and Loading:Calls RDBConfig.parseArguments(args) to process RDB-related command-line arguments (e.g., --dir, --dbfilename).Calls RDBKeyHandler.loadRdbFile(...) to load any existing data from the RDB file into the store map.Start Expiry Cleanup:SetGetHandler.startExpiryCleanup(store, expiry): Initiates the background thread that periodically removes expired keys.Command-Line Argument Parsing:Initializes currentServerPort to 6379, and masterHost/masterPort to null/-1.Iterates through args to find --port and --replicaof:If --port is found, parses the next argument as currentServerPort.If --replicaof is found, sets isMaster to false, parses the next two arguments as masterHost and masterPort.Role Logging and Replica Connection:Logs the server's determined role (master or slave) and its listening port.If isMaster is false:Logs that it's replicating from the specified master.Calls ReplicaClient.connectToMaster(masterHost, masterPort, store, expiry) to initiate the replica handshake and data synchronization process.Increments countofReplica (this might be intended for master-side replica counting, but here it's on the replica itself).Server Socket Setup and Client Acceptance:Crucial Correction: The ServerSocket is bound to currentServerPort, which is the port this specific server instance should listen on. The original code had masterPort, which would be incorrect for a replica listening on its own port.serverSocket.setReuseAddress(true): Allows the server to bind to a port that might be in a TIME_WAIT state, useful for quick restarts.Enters an infinite while (true) loop to continuously accept incoming client connections:clientSocket = serverSocket.accept(): Blocks until a new client connects.Logs the client's connection details.new ClientHandler(...).start(): Creates a new ClientHandler thread for each connected client, passing all shared data structures and server configuration flags (store, expiry, streams, lastStreamIds, isMaster, connectedReplicasWriters, master_replID, master_repl_offset). This allows each client to be handled concurrently.Error Handling: Catches IOException during server socket operations and logs the error.Client Handler (ClientHandler.java)ClientHandler.java extends Thread and is responsible for managing communication with a single connected client. Each ClientHandler instance runs in its own dedicated thread.Functionality:Initializes with the client's Socket and shared data structures like the key-value store, expiry map, streams map, and replication-related parameters.Continuously reads incoming commands from the client, parses them according to the RESP protocol, and dispatches them to appropriate handlers or processes them directly.Sends RESP-formatted responses back to the client.Manages connection state and handles disconnection events.For a master server, it includes logic to track connected replicas and, for certain commands, propagate updates to them (though direct propagation for SET is not shown in this ClientHandler's run method, the connectedReplicasWriters list suggests this capability).Class Fields:private Socket clientSocket: The Socket object representing the connection to the client.private ConcurrentHashMap<String, String> store: A shared, thread-safe hash map holding the key-value data of the Redis-like store.private ConcurrentHashMap<String, Long> expiry: A shared, thread-safe hash map storing the expiration timestamps (in milliseconds since epoch) for keys in the store.private ConcurrentHashMap<String, TreeMap<String, ConcurrentHashMap<String, String>>> streams: A shared, thread-safe map to store Redis Stream data. The outer map holds stream names, and the inner TreeMap (sorted by ID) holds stream entries, each containing a map of field-value pairs.private ConcurrentHashMap<String, String> lastStreamIds: A shared, thread-safe map to keep track of the last generated stream ID for each stream key.private boolean isMaster: A flag indicating whether the current server instance is configured as a master or a replica.private CopyOnWriteArrayList<BufferedWriter> connectedReplicasWriters: A thread-safe list of BufferedWriter objects, used by a master server to send commands and responses to its connected replicas.private String master_replID: The replication ID of the master server. This is a unique ID used during the replication handshake.private int master_repl_offset: The replication offset of the master server. This indicates how many bytes of the replication stream the master has already produced.Constructor (ClientHandler(...)):The constructor takes all the necessary shared data structures and server configuration parameters as arguments. These are then assigned to the ClientHandler's instance variables, allowing it to interact with the global state of the server and other connected components (like SetGetHandler, StreamHandler, RDBConfig, ReplicaClient).run() Method - Detailed Algorithm:The run() method contains the core logic for reading, parsing, and processing client commands in an infinite loop until the client disconnects or a protocol error occurs.Initialization:It sets up BufferedReader and BufferedWriter using clientSocket.getInputStream() and clientSocket.getOutputStream() respectively, ensuring they are automatically closed via try-with-resources.A connectionActive boolean flag is initialized to true to control the main command processing loop.Command Reading Loop:The while (connectionActive) loop continuously reads the first line of an incoming command.Client Disconnection Check: If reader.readLine() returns null, it means the client has gracefully disconnected. A message is printed, connectionActive is set to false, and the loop terminates.RESP Array Parsing:Array Indicator Validation: The first line must start with * (e.g., *3). If not, an "-ERR invalid protocol: Expected '*' for array" error is sent to the client, and the connection is marked inactive.Argument Count Parsing: The number following * is parsed as argsCount (e.g., from *3, argsCount becomes 3). NumberFormatException is caught if parsing fails.Positive Argument Count Check: argsCount must be greater than 0. If not, an error is returned.Argument Storage: A String[] arguments array is initialized to store the parsed command and its parameters.RESP Bulk String Parsing Loop:A for loop iterates argsCount times to read each individual argument of the command.Bulk Length Line Reading: Inside the loop, reader.readLine() reads the line specifying the length of the bulk string (e.g., $4).Bulk Length Indicator Validation: This line must start with $. If not, "-ERR invalid protocol: Expected '$' for bulk string length" is sent, and the connection becomes inactive.Bulk Length Parsing: The number following $ is parsed as bulkLen (e.g., from $4, bulkLen becomes 4). NumberFormatException is caught.Bulk String Data Reading: A char[] buffer of size bulkLen is created. reader.read(buffer, 0, bulkLen) reads the actual command/argument bytes.Incomplete Read Check: If bytesRead is not equal to bulkLen, it indicates an incomplete bulk string read, and an error is sent.Argument Storage: The buffer is converted to a String and stored in the arguments array at the current index i.Trailing \r\n Consumption: reader.readLine() is called again to consume the \r\n that terminates the bulk string data.Command Dispatch:After all arguments are successfully parsed, the first argument (arguments[0]) is converted to uppercase and assigned to command.A switch statement then dispatches to specific logic based on the command:PING:If arguments.length > 1, it means PING was sent with an argument (e.g., PING hello). The argument is echoed back as a RESP bulk string (e.g., $5\r\nhello\r\n).Otherwise (just PING), it responds with a simple string +PONG\r\n.ECHO:Requires at least one argument after ECHO.It concatenates all arguments from arguments[1] onwards, separated by spaces.The resulting string is sent back as a RESP bulk string.If no argument is provided, it returns a "-ERR wrong number of arguments for 'echo' command".SET / GET:These commands are delegated to a separate static helper class, SetGetHandler, which is responsible for their specific logic, including interaction with the store and expiry maps.SetGetHandler.handleCommand(arguments, store, expiry, isMaster, connectedReplicasWriters, writer);CONFIG:Specifically handles CONFIG GET <parameter>.Checks for arguments.length == 3 and arguments[1] being GET (case-insensitive).It retrieves the value for dir or dbfilename from the RDBConfig static class.Responds with a RESP array of two bulk strings: *2\r\n$3\r\ndir\r\n$N\r\n<dir_value>\r\n or *0\r\n if the parameter is not found or not supported.Handles invalid CONFIG GET arguments.KEYS:Only supports KEYS *.If arguments.length != 2 or arguments[1] is not *, it returns "-ERR only KEYS * is supported".Otherwise, it responds with a RESP array containing all keys currently in the store (by iterating store.keySet()), each as a separate bulk string.INFO:Specifically handles INFO replication.If arguments.length == 2 and arguments[1] is replication (case-insensitive).Constructs an infoString detailing the server's role (master or slave).If the server is a master (isMaster is true), it also includes master_replid and master_repl_offset.The infoString is sent back as a RESP bulk string.Handles illegal arguments.REPLCONF:Used for replication handshake and acknowledgment.If this server is a master, and the replica sends REPLCONF listening-port <port>, the writer associated with this client is added to the master's connectedReplicasWriters list, effectively registering the replica.If REPLCONF getack is received, it responds with a REPLCONF ACK <offset> array, using Main.master_repl_offset for the master's current replication offset. Note: Original code uses ReplicaClient.offset which would be for the replica's offset, but ClientHandler on master should use master's offset.Always responds with +OK\r\n for REPLCONF commands, regardless of the specific sub-command.PSYNC:Handles the full synchronization command.If the server is a master, it responds with +FULLRESYNC <master_replID> 0\r\n.Immediately after, it sends a hardcoded, empty RDB (Redis Database) file to the replica. This is done by writing a RESP bulk string header (e.g., $<length>\r\n) followed by the raw RDB bytes directly to the OutputStream to bypass BufferedWriter's character encoding and buffer.If the server is a slave and receives PSYNC, it responds with "-ERR PSYNC command only supported on master" and disconnects the client.WAIT:Responds with an integer reply (:<count>\r\n) indicating the number of connected replicas known by the master. It retrieves this count using Main.getreplicacount().XADD:Delegates stream-related commands to StreamHandler.StreamHandler.handleStreamCommand(arguments, lastStreamIds, streams, writer);Includes a try-catch block to send "-ERR" responses if StreamHandler throws an exception.TYPE:Determines the type of data stored at a given key.Checks if the key exists in the store (ConcurrentHashMap for strings). If found, it responds with +string\r\n.If not a string, it checks if the key exists in the streams (ConcurrentHashMap for streams). If found, it responds with +stream\r\n.If the key is not found in either, it responds with +none\r\n.default:For any unknown command, it responds with "-ERR unknown command '<command>'\r\n" and sets connectionActive to false, disconnecting the client.Error Handling & Connection Management:A try-catch block surrounds the entire run() method to catch IOException during network operations.It specifically checks for "Connection reset by peer" messages to provide a more descriptive log for client-initiated disconnections.A finally block ensures that the clientSocket is properly closed, regardless of whether the connection terminated gracefully or due to an error.Data Store (SetGetHandler.java and associated data structures)The SetGetHandler class is a static utility that encapsulates the logic for the SET and GET commands, interacting directly with the shared ConcurrentHashMap for the main data store (store) and for key expirations (expiry). It also manages the propagation of SET commands in a master-replica setup.Key Data Structures:ConcurrentHashMap<String, String> store: The primary in-memory data store for string key-value pairs. ConcurrentHashMap ensures thread-safe operations (puts, gets, removes) across multiple ClientHandler threads.ConcurrentHashMap<String, Long> expiry: Stores the expiration timestamp (milliseconds since epoch) for keys. If a key is present in expiry, it means it has a time-to-live (TTL).handleCommand(String[] args, ...) Method - Detailed Algorithm:This static method is called by ClientHandler to process SET and GET requests. It takes the parsed command arguments, the shared store and expiry maps, the isMaster flag, the list of connectedReplicasWriters, and the BufferedWriter for the current client.Command Type Determination:It converts args[0] (the command name) to uppercase and uses a switch statement to differentiate between SET and GET.SET Command Handling:Argument Validation: Checks if at least a key and a value are provided (args.length < 3). If not, it sends a "-ERR wrong number of arguments for 'SET'" error.Key and Value Extraction: Extracts the key (args[1]) and value (args[2]).Option Parsing (EX, PX, NX, XX):It iterates through the remaining arguments (from args[3] onwards) to parse optional parameters.EX <seconds>: Parses the next argument as an integer seconds. Calculates expireAt as System.currentTimeMillis() + seconds * 1000L. Includes error handling for non-integer or missing seconds.PX <milliseconds>: Parses the next argument as an integer ms. Calculates expireAt as System.currentTimeMillis() + ms. Includes error handling for non-integer or missing milliseconds.NX: Sets a nx boolean flag to true. Means "set only if key does not exist".XX: Sets an xx boolean flag to true. Means "set only if key does exist".Unknown Options: If an unrecognized option is found, it sends "-ERR unknown option for SET".NX and XX Conflict Check: Ensures that NX and XX are not used simultaneously, returning an error if they are.Conditional Set Logic:Determines keyExists by checking store.containsKey(key).If (nx && keyExists) (NX was specified but key already exists) or (xx && !keyExists) (XX was specified but key doesn't exist), the SET operation is not performed. The client receives a $-1\r\n (null bulk string) reply, indicating no operation was done.Otherwise (the SET condition is met):store.put(key, value): The key-value pair is stored in the main store.Expiration Handling:If expireAt is not null (meaning EX or PX was used), the key and its expiration timestamp are added to the expiry map.If expireAt is null, any existing expiration for the key is removed from the expiry map.The client receives a +OK\r\n reply.A performedSet flag is set to true to indicate that a write operation occurred.Replication Logic (Master Side):The check if (!isMaster && performedSet) in your code seems to indicate that this block runs on a replica instance if it performs a SET (which is unusual for a typical replica, as replicas usually receive commands from master). However, based on the context of a master propagating to replicas, this condition likely means if (isMaster && performedSet). Assuming the intent is for the master to propagate:If the server is acting as a master and the SET operation was successfully performed (performedSet is true), the original SET command (including all its arguments and options) is reconstructed into its full RESP array format.This RESP command string is then passed to the propagateCommandToReplicas helper method.GET Command Handling:Argument Validation: Checks if exactly one argument (the key) is provided (args.length != 2). If not, it sends a "-ERR wrong number of arguments for 'GET'".Key Extraction: Extracts the key (args[1]).Value Retrieval: Retrieves the value from the store using store.get(key).Expiration Check:It fetches the expireTime for the key from the expiry map.If an expireTime exists and the current time (System.currentTimeMillis()) is past the expireTime, the key is considered expired.In this case, the key-value pair is removed from both store and expiry, and value is set to null.Response:If value is not null (meaning the key exists and is not expired), the value is sent back as a RESP bulk string (e.g., $7\r\nmyvalue\r\n).If value is null (key not found or expired), a $-1\r\n (null bulk string) is sent.Default Case:A default case is included, though ClientHandler should ideally filter commands before reaching this helper. It sends "-ERR unknown command" if an unhandled command reaches here.Flush:clientWriter.flush() is called at the end of handleCommand to ensure that all buffered response data is sent immediately to the client.startExpiryCleanup(ConcurrentHashMap<String, String> store, ConcurrentHashMap<String, Long> expiry) Method - Detailed Algorithm:This static method creates and starts a background daemon thread responsible for proactively removing expired keys from the store and expiry maps. This ensures that memory is reclaimed and GET requests don't repeatedly encounter expired keys.Thread Creation:A new Thread is created (cleanupThread).It is set as a daemon thread (cleanupThread.setDaemon(true)). This is crucial because it allows the JVM to exit gracefully even if this thread is still running, as daemon threads do not prevent application termination.A name is assigned ("ExpiryCleanupThread") for easier debugging.Cleanup Loop (run() method of the cleanup thread):The while (true) loop makes the thread run indefinitely until interrupted or the JVM shuts down.Sleep Interval: Thread.sleep(100) pauses the thread for 100 milliseconds, controlling how frequently it checks for expired keys. This prevents the cleanup thread from consuming excessive CPU cycles.Current Time: long now = System.currentTimeMillis(); gets the current time to compare against expiration timestamps.Safe Iteration and Removal:An Iterator<String> keyIterator = expiry.keySet().iterator(); is used to iterate over the keys in the expiry map. Using an Iterator for ConcurrentHashMap.keySet().iterator() provides weakly consistent iteration, meaning it might not reflect changes that happened after the iterator was created, but it won't throw ConcurrentModificationException.Inside the while (keyIterator.hasNext()) loop:String key = keyIterator.next(): Retrieves the current key.Long exp = expiry.get(key): Retrieves its expiration time.Expiration Check: If exp is not null and now is greater than exp (i.e., the key has expired):store.remove(key): The key is removed from the main data store.keyIterator.remove(): The key is safely removed from the expiry map using the iterator's remove() method.A log message indicates the key has been removed.Error Handling:InterruptedException is caught to allow the thread to gracefully exit if it's told to stop (e.g., during server shutdown).A general Exception catch-all is included for other unexpected errors during cleanup.propagateCommandToReplicas(String command, CopyOnWriteArrayList<BufferedWriter> replicas) Method - Detailed Algorithm:This static helper method is responsible for sending a command to all currently connected replica clients.Logging: It logs the command being propagated for debugging.Iteration over Replicas:It iterates through the CopyOnWriteArrayList<BufferedWriter> replicas.CopyOnWriteArrayList: This list is specifically chosen because it's thread-safe for iterations while modifications (like adding or removing writers) are happening. Iterators on this list operate on a snapshot of the list at the time the iterator was created, preventing ConcurrentModificationException.Command Sending:For each BufferedWriter (writer) in the list:writer.write(command): The full RESP command string is written to the replica's output stream.writer.flush(): The data is immediately sent over the network.Error Handling for Disconnected Replicas:A try-catch block surrounds the write operations.If an IOException occurs (e.g., the replica socket is closed or reset), it means that replica has disconnected.An error message is logged, and the problematic writer is removed from the replicas list (replicas.remove(writer)). This is safe with CopyOnWriteArrayList and ensures that subsequent propagation attempts don't try to write to a defunct connection.Replication Client (ReplicaClient.java)The ReplicaClient.java class handles the logic for a server instance operating as a replica, enabling it to connect to a master server and synchronize its data. It's a static utility class designed to initiate and maintain the replication handshake and command reception.Class Fields:static ConcurrentHashMap<String, String> ReplicaStore: A static reference to the replica's local key-value store, which will be synchronized with the master.private static ConcurrentHashMap<String, Long> ReplicaExpiry: A static reference to the replica's local expiry map, also synchronized.private static Socket masterSocket: A static reference to the Socket connection established with the master server.public static Integer offset = 0: The current replication offset of the replica. This tracks how many bytes of the replication stream the replica has processed from the master.connectToMaster(String host, int port, ConcurrentHashMap<String, String> store, ConcurrentHashMap<String, Long> expiry) Method - Detailed Algorithm:This method initiates the replica's connection to the master and starts the replication handshake process in a new thread.Thread Initialization: The entire connection and handshake logic runs within a new Thread to avoid blocking the main server thread.Store and Expiry Assignment: The local ReplicaStore and ReplicaExpiry static fields are assigned the store and expiry maps passed from the main Server class, ensuring the replica operates on the same data structures as other client handlers.Expiry Cleanup: SetGetHandler.startExpiryCleanup(ReplicaStore, ReplicaExpiry) is called to ensure that the replica's store also has a background thread for expiring keys.Master Socket Connection:masterSocket = new Socket(host, port): Establishes a TCP connection to the master server.Logs the successful connection.I/O Stream Setup:BufferedWriter writer: For sending commands to the master.BufferedReader reader: For receiving responses and commands from the master.Replication Handshake Steps:Step 1: PING:Sends a PING command (*1\r\n$4\r\nPING\r\n) to the master using the sendCommand helper.Verifies the response is +PONG. If not, an error is logged, and the connection is closed.Step 2: REPLCONF listening-port:Sends REPLCONF listening-port 6380 (assuming replica listens on port 6380 for this example) to the master. This registers the replica's listening port with the master.Verifies the response is +OK.Step 3: REPLCONF capa psync2:Sends REPLCONF capa psync2 to inform the master of its synchronization capabilities.Verifies the response is +OK.Step 4: PSYNC ? -1:Sends PSYNC ? -1 to request a full resynchronization from the master. ? indicates no known master replication ID, and -1 indicates no known offset (requesting full sync).Unlike previous steps, this command is written directly to the writer and flushed without immediately reading a single line response, as the master's reply will be +FULLRESYNC followed by a binary RDB file.PSYNC Response Handling:Reads the +FULLRESYNC line from the master.If +FULLRESYNC is received, it calls readRDBFile(masterSocket.getInputStream()) to consume the incoming RDB snapshot.After the RDB file is consumed, Main.isReplicaReady = true is set (assuming isReplicaReady is a static flag in Main.java), signaling that the replica is ready.Finally, it calls readMasterCommands(reader) to start a new thread that continuously reads subsequent commands from the master's replication stream.If an unexpected PSYNC response is received, an error is logged, and the socket is closed.Error Handling: A broad try-catch block handles general exceptions during the connection and handshake, logging errors and printing stack traces.Finally Block: Ensures masterSocket is closed if an error occurs before readMasterCommands takes over persistent reading.sendCommand(BufferedWriter writer, BufferedReader reader, String command) Method:A private static helper method to send a RESP command string to the master and read its single-line response.Logs the command being sent.Writes the command string to the writer and flushes it.Reads a single line from the reader as the response and returns it.readRDBFile(InputStream inputStream) Method - Detailed Algorithm:This method is crucial for handling the binary RDB file sent by the master after a PSYNC command.Read Bulk String Length:A temporary BufferedReader is used to read the initial RESP bulk string header line ($<length>\r\n).It parses the rdbLength from this line.Includes validation to ensure the line starts with $ and the length is a valid number.Consume Binary RDB Data:A byte[] buffer is used to read chunks of raw binary data from the InputStream directly. This bypasses character encoding issues that would arise from using BufferedReader for binary data.It reads bytesToRead (up to buffer.length or remaining rdbLength) at a time until all rdbLength bytes are consumed.Checks for unexpected end of stream (read == -1).Logs the consumption process.readMasterCommands(BufferedReader reader) Method - Detailed Algorithm:This method runs in a dedicated thread to continuously listen for and process commands sent by the master after the initial PSYNC and RDB transfer.Continuous Reading Loop: An infinite while (true) loop continuously reads lines from the master's BufferedReader.Master Disconnection: If reader.readLine() returns null, the master has closed the connection, and the loop breaks.Command Parsing and Dispatch:RESP Array: If the line starts with * (indicating a command array, like a SET command):Parses the numArgs.Iterates numArgs times to read each argument (length line followed by value).Offset Tracking: For each argument, offset is incremented by the argument's byte length plus 2 (for the \r\n terminator). This tracks the replication offset.Command Type Check: If parsedArgs[0] is "SET" (case-insensitive), it calls ReplicaSetCommand(parsedArgs) to apply the command to the replica's local store.Logs received unsupported commands.Simple String (+): If the line starts with +, it's a simple string, which is logged.Bulk String ($): If the line starts with $, it's a bulk string length indicator. The actual value is consumed by calling reader.readLine() again.Unknown Line: Logs any unrecognized lines.Error Handling & Socket Closure: Includes a try-catch for IOException and a finally block to ensure masterSocket is closed if the reading thread terminates.ReplicaSetCommand(String... args) Method:This static method applies a SET command received from the master to the replica's local data store. It's similar to SetGetHandler's SET logic but adapted for replica application.Argument Validation: Checks for a minimum of 3 arguments (command, key, value).Key and Value Extraction: Extracts key and value.Optional Argument Parsing (EX, PX): Parses EX (seconds) or PX (milliseconds) options, calculating the expireAt timestamp. Includes basic error logging for invalid number formats.Store Update:ReplicaStore.put(key, value): Stores the key-value pair.If expireAt is not null, ReplicaExpiry.put(key, expireAt): Updates the expiry map.If expireAt is null, ReplicaExpiry.remove(key): Removes any existing expiry.Logs the applied SET command.encodeRESPCommand(String... args) Method:A static utility method to encode a variadic number of string arguments into a RESP array format. This is useful for constructing commands to send over the network.Constructs the RESP array header (*<num_args>\r\n).For each argument, appends the bulk string header ($<length>\r\n) and the argument itself, followed by \r\n.Returns the complete RESP string.Stream Handling (StreamHandler.java)The StreamHandler.java class is a static utility responsible for processing Redis Stream commands, specifically XADD. It manages the storage of stream entries and the generation/validation of stream IDs.Nested Exception Class:private static class StreamIdValidationException extends Exception: A custom exception class specifically for errors related to stream ID validation, providing more precise error messages.handleStreamCommand(String[] arguments, ConcurrentHashMap<String, String> lastStreamIds, ConcurrentHashMap<String, TreeMap<String, ConcurrentHashMap<String, String>>> streams, BufferedWriter clientWriter) Method - Detailed Algorithm:This static method processes an XADD command received from a client.Argument Validation:Checks for a minimum of 4 arguments (XADD <key> <id> <field> <value>). If not met, returns "-ERR wrong number of arguments for 'XADD' command".Stream Key and Requested ID Extraction:Extracts streamKey (arguments[1]) and requestedId (arguments[2]).Stream ID Generation/Validation:Delegates the crucial task of generating a new stream ID (if * is provided) or validating an explicit ID to generateAndValidateStreamId.A try-catch block handles StreamIdValidationException (for user-facing ID errors) and NumberFormatException (for internal malformed lastStreamIds), sending appropriate "-ERR" responses to the client. The result is stored in finalEntryId.Field-Value Pair Collection:Checks if the number of field-value pairs (arguments.length - 3) is even. If odd, it sends "-ERR odd number of arguments for field-value pairs".Iterates through the remaining arguments (from arguments[3] onwards, incrementing by 2) to extract field and value pairs.These pairs are stored in a new ConcurrentHashMap<String, String> entryData.Store New Stream Entry:streams.computeIfAbsent(streamKey, k -> new TreeMap<>()): Retrieves the TreeMap associated with the streamKey. If the stream doesn't exist, a new empty TreeMap is created and associated with the key (thread-safe operation). The TreeMap inherently keeps stream entries sorted by their IDs.streamEntries.put(finalEntryId, entryData): The finalEntryId and its corresponding entryData are added to the stream's TreeMap.Update Last Stream ID:lastStreamIds.put(streamKey, finalEntryId): The lastStreamIds map is updated with the finalEntryId for the current streamKey.Send Response:The finalEntryId is sent back to the client as a RESP bulk string ($<length>\r\n<id>\r\n).generateAndValidateStreamId(String streamKey, String requestedId, ConcurrentHashMap<String, String> lastStreamIds) Method - Detailed Algorithm:This private static helper method is responsible for the complex logic of handling stream IDs (* or explicit timestamp-sequence).Null Argument Checks: Basic Objects.requireNonNull calls ensure critical input parameters are not null.Retrieve Last ID:lastIdForStream = lastStreamIds.getOrDefault(streamKey, "0-0"): Retrieves the last recorded stream ID for the streamKey. If no previous ID exists (new stream), it defaults to "0-0".Splits lastIdForStream into lastIdParts (timestamp and sequence).Parses lastMillisecondsTime and lastSequenceNumber from these parts. Includes NumberFormatException handling for malformed stored IDs.requestedId.equals("*") (Auto-Generation Logic):This is the standard way clients ask Redis to generate a unique, monotonically increasing ID.long currentMillis = System.currentTimeMillis(): Gets the current system time.Case 1: currentMillis == lastMillisecondsTime: If the current timestamp is the same as the last entry's timestamp, the sequence number is incremented (lastSequenceNumber + 1). The new ID is currentMillis + "-" + (lastSequenceNumber + 1).Case 2: currentMillis > lastMillisecondsTime: If the current timestamp is greater, a new ID is generated with the current timestamp and a sequence number of 0. The new ID is currentMillis + "-" + "0".Case 3: currentMillis < lastMillisecondsTime: This implies the system clock went backward or the last ID was in the future. To maintain monotonicity, the new ID is generated by incrementing the last known timestamp and setting the sequence to 0. The new ID is (lastMillisecondsTime + 1) + "-" + "0".Explicit ID Provided Logic:Format Validation: Checks if requestedId has at least two parts separated by - (e.g., timestamp-sequence). If not, throws StreamIdValidationException.Wildcard Sequence timestamp-*: If the sequence part is *, it increments the lastSequenceNumber (based on the lastMillisecondsTime for that stream if lastMillisecondsTime matches requestedIdParts[0]). Note: The provided code's if (requestedIdParts[1].equals("*")) directly increments lastSequenceNumber + 1 for the given timestamp, which means it assumes the provided timestamp is valid and will be equal to lastMillisecondsTime or greater, and only increments the sequence. This is a subtle difference from full Redis behavior for timestamp-*.Full Explicit ID timestamp-sequence:Parses newMillisecondsTime and newSequenceNumber from the requestedIdParts. Throws StreamIdValidationException for invalid numbers.Rule 1: ID must be greater than 0-0: If newMillisecondsTime is 0 and newSequenceNumber is 0, throws StreamIdValidationException.Rule 2: ID must be strictly greater than the last entry's ID:Compares newMillisecondsTime with lastMillisecondsTime. If newMillisecondsTime is smaller, it's invalid.If timestamps are equal (newMillisecondsTime == lastMillisecondsTime), newSequenceNumber must be strictly greater than lastSequenceNumber. If not, it's invalid.If all checks pass, the requestedId is considered valid and is returned.
